using Microsoft.CodeAnalysis;
using System.Text;
using System.Text.Json;

namespace Helldivers.SourceGen;

/// <summary>
/// A sample source generator that creates C# classes based on the text file (in this case, Domain Driven Design ubiquitous language registry).
/// When using a simple text file as a baseline, we can create a non-incremental source generator.
/// </summary>
[Generator]
public class StaticJsonSourceGenerator : ISourceGenerator
{
    /// <inheritdoc />
    public void Initialize(GeneratorInitializationContext context)
    {
        // No initialization required for this generator.
    }

    /// <inheritdoc />
    public void Execute(GeneratorExecutionContext context)
    {
        foreach (var file in context.AdditionalFiles)
        {
            if (file is null)
                continue;

            var name = Path.GetFileNameWithoutExtension(file.Path);
            name = $"{char.ToUpper(name[0])}{name.Substring(1)}";

            try
            {
                var json = file.GetText(context.CancellationToken)?.ToString() ?? throw new InvalidOperationException($"Cannot generate C# from missing JSON file {file.Path}");

                var (type, value) = name.ToLowerInvariant() switch
                {
                    "planets" => ParsePlanetsDictionary(json),
                    "biomes" => ParseBiomesDictionary(json),
                    "environmentals" => ParseEnvironmentalsDictionary(json),
                    "factions" => ParseFactionsDictionary(json),
                    _ => throw new Exception($"Generator does not know how to parse {name}")
                };

                var source = $@"// <auto-generated />
#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member
using global::System.Collections.Generic;
using global::Helldivers.Models.Domain.Localization;

namespace Helldivers.Models;

public static partial class Static
{{
    /// <summary>Public list of {name} entries from {Path.GetFileName(file.Path)}</summary>
    public static {type} {name} = {value};
}}
";

                context.AddSource($"{name}.g.cs", source);
            }
            catch (Exception exception)
            {
                context.AddSource($"{name}.g.cs", $"// An exception was thrown processing {name}.json\n{exception.ToString()}");
                context.ReportDiagnostic(
                    Diagnostic.Create(
                        new DiagnosticDescriptor(
                            id: "HDJSON", // Unique ID for your error
                            title: "JSON source generator failed", // Title of the error
                            messageFormat: $"An error occured generating C# code from JSON files: {exception}", // Message format
                            category: "HD2", // Category of the error
                            DiagnosticSeverity.Error, // Severity of the error
                            isEnabledByDefault: true // Whether the error is enabled by default
                        ),
                        Location.None // No specific location provided for simplicity
                    )
                );
            }
        }
    }

    /// <summary>
    /// Parses a JSON file that's an object where keys are numerical and values are names (strings).
    /// </summary>
    private (string Type, string Source) ParseFactionsDictionary(string json)
    {
        var builder = new StringBuilder("new Dictionary<int, string>()\n\t{\n");
        var entries = JsonSerializer.Deserialize<Dictionary<string, string>>(json)!;
        foreach (var pair in entries)
            builder.AppendLine($@"{'\t'}{'\t'}{{ {pair.Key}, ""{pair.Value}"" }},");

        builder.Append("\t}");
        return ("IReadOnlyDictionary<int, string>", builder.ToString());
    }

    private (string Type, string Source) ParsePlanetsDictionary(string json)
    {
        var builder = new StringBuilder("new Dictionary<int, (LocalizedMessage Name, string Sector, string Biome, List<string> Environmentals)>()\n\t{\n");
        var document = JsonDocument.Parse(json);
        foreach (var property in document.RootElement.EnumerateObject())
        {
            var index = property.Name;
            var name = property.Value.GetProperty("name").GetString();
            var names = property
                .Value
                .GetProperty("names")
                .EnumerateObject()
                .ToDictionary(prop => prop.Name, prop => prop.Value.GetString()!);
            var sector = property.Value.GetProperty("sector").GetString();
            var biome = property.Value.GetProperty("biome").GetString();
            var environmentals = property
                .Value
                .GetProperty("environmentals")
                .EnumerateArray()
                .Select(prop => $@"""{prop.GetString()!}""")
                .ToList();

            builder.AppendLine($@"{'\t'}{'\t'}{{ {index}, (LocalizedMessage.FromStrings([{string.Join(", ", names.Select(pair => $@"new KeyValuePair<string, string>(""{pair.Key}"", ""{pair.Value}"")"))}]), ""{sector}"", ""{biome}"", [{string.Join(", ", environmentals)}]) }},");
        }

        builder.Append("\t}");
        return ("IReadOnlyDictionary<int, (LocalizedMessage Name, string Sector, string Biome, List<string> Environmentals)>", builder.ToString());
    }

    private (string Type, string Source) ParseBiomesDictionary(string json)
    {
        var builder = new StringBuilder("new Dictionary<string, Helldivers.Models.V1.Planets.Biome>()\n\t{\n");
        var entries = JsonSerializer.Deserialize<Dictionary<string, Dictionary<string, string>>>(json)!;
        foreach (var pair in entries)
            builder.AppendLine($@"{'\t'}{'\t'}{{ ""{pair.Key}"", new Helldivers.Models.V1.Planets.Biome(""{pair.Value["name"]}"", ""{pair.Value["description"]}"") }},");

        builder.Append("\t}");
        return ("IReadOnlyDictionary<string, Helldivers.Models.V1.Planets.Biome>", builder.ToString());
    }

    private (string Type, string Source) ParseEnvironmentalsDictionary(string json)
    {
        var builder = new StringBuilder("new Dictionary<string, Helldivers.Models.V1.Planets.Hazard>()\n\t{\n");
        var entries = JsonSerializer.Deserialize<Dictionary<string, Dictionary<string, string>>>(json)!;
        foreach (var pair in entries)
            builder.AppendLine($@"{'\t'}{'\t'}{{ ""{pair.Key}"", new Helldivers.Models.V1.Planets.Hazard(""{pair.Value["name"]}"", ""{pair.Value["description"]}"") }},");

        builder.Append("\t}");
        return ("IReadOnlyDictionary<string, Helldivers.Models.V1.Planets.Hazard>", builder.ToString());
    }
}
