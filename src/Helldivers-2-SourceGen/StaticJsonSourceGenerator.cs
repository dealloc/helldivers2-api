using Microsoft.CodeAnalysis;
using System.Text;
using System.Text.Json;

namespace Helldivers.SourceGen;

/// <summary>
/// A sample source generator that creates C# classes based on the text file (in this case, Domain Driven Design ubiquitous language registry).
/// When using a simple text file as a baseline, we can create a non-incremental source generator.
/// </summary>
[Generator]
public class StaticJsonSourceGenerator : ISourceGenerator
{
    /// <inheritdoc />
    public void Initialize(GeneratorInitializationContext context)
    {
        // No initialization required for this generator.
    }

    /// <inheritdoc />
    public void Execute(GeneratorExecutionContext context)
    {
        foreach (var file in context.AdditionalFiles)
        {
            if (file is null)
                continue;

            var name = Path.GetFileNameWithoutExtension(file.Path);
            name = $"{char.ToUpper(name[0])}{name.Substring(1)}";

            try
            {
                var json = file.GetText(context.CancellationToken)!.ToString();

                var (type, value) = name.ToLowerInvariant() switch
                {
                    "planets" => ParseNumericDictionary(json),
                    "factions" => ParseNumericDictionary(json),
                    "sectors" => ParseNumericListDictionary(json),
                    _ => throw new Exception($"Generator does not know how to parse {name}")
                };

                var source = $@"// <auto-generated />
#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member
using global::System.Collections.Generic;

namespace Helldivers.Models;

public static partial class Static
{{
    /// <summary>Public list of {name} entries from {Path.GetFileName(file.Path)}</summary>
    public static {type} {name} = {value};
}}
";

                context.AddSource($"{name}.g.cs", source);
            }
            catch (Exception exception)
            {
                context.AddSource($"{name}.g.cs", $"// An exception was thrown processing {name}.json\n{exception.ToString()}");
            }
        }
    }

    /// <summary>
    /// Parses a JSON file that's an object where keys are numerical and values are names (strings).
    /// </summary>
    private (string Type, string Source) ParseNumericDictionary(string json)
    {
        var builder = new StringBuilder("new Dictionary<int, string>()\n\t{\n");
        var entries = JsonSerializer.Deserialize<Dictionary<string, string>>(json)!;
        foreach (var pair in entries)
            builder.AppendLine($@"{'\t'}{'\t'}{{ {pair.Key}, ""{pair.Value}"" }},");

        builder.Append("\t}");
        return ("IReadOnlyDictionary<int, string>", builder.ToString());
    }

    /// <summary>
    /// Parses a JSON file that's an object where keys are strings and values are lists of integers.
    /// </summary>
    private (string Type, string Source) ParseNumericListDictionary(string json)
    {
        var builder = new StringBuilder("new Dictionary<string, List<int>>()\n\t{\n");
        var entries = JsonSerializer.Deserialize<Dictionary<string, List<int>>>(json, new JsonSerializerOptions())!;
        foreach (var pair in entries)
        {
            var values = string.Join(", ", pair.Value);
            builder.AppendLine($@"{'\t'}{'\t'}{{ ""{pair.Key}"", [{values}] }},");
        }

        builder.Append("\t}");
        return ("IReadOnlyDictionary<string, List<int>>", builder.ToString());
    }
}
